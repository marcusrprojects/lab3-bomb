phase_1: "To infinity...and beyond!"

This code moves the value at address 0x402547 into the register %esi, and
compares the inputted value to this. Calling on <strings_not_equal>, it 
will pass the test so that it will jump to the next stage if they are equal,
harnessing condition codes with "test." If not, it will blow up. Therefore,
the value must equal "To infinity...and beyond!" as this is the string that
is located in the address 0x402547.

phase_2: 3 4 6 9 13 18

To find this solution, I followed the function to see where it compares values
and decides whether or not to jump, and on what conditions. Initially, one needed
to understand the purpose of the read_six_numbers function, which checks to see if
there are 6 numbers inputted by the user or it jumps to boom. Then, the function
checks to make sure the first value is positive and will continue from there.
In using GDB and examining the eax register for each one, I was able to correct the 6
values sequentially until the rbx register, which would be loaded with the next value
to test, was equal to the eax register's value.

phase_3: 3 255

For this phase, the function first checks for how many numbers the user inputs, which must
be more than 1, and there cannot be strings. It stores the number count in eax and continues.
Then, it compares the first number with 7 and if it is negative or greater than 7, it blows up.
Otherwise, it continues. It then puts this number in the eax register. It will use this value to
decide how many mov commands down it should jump to. This mov command determines eax's new value
and this value must match up with the user's second inputted value to pass this phase.

phase_4: 60 3 2

For this phase, the function first uses __isoc99_sscanf@plt to discover how many numbers there are.
If there is 1 number only, 1 is stored in the eax register. If there are 2+ numbers inputted, it returns
2. Otherwise, if a string is inputted, it returns 0. As long as the eax register contains 2 after this 
step, one can continue without a boom. Next, it checks the second inputted value and one can only
continue without a boom if this value subtracted by 2 is nonnegative and under 2, so it must be either
3 or 2. Next, it moves this inputted value into the register for the second argument, moves 6 into the
register for the first argument and computes a func4, which will ultimately alter the eax value.
This new value generated by this function should be equal to the first register's value.
As long as this is true, memory becomes uninitialized and the function is returned, completing this stage.

phase_5: cicjop

In this phase, the function first checks how long the string is and immediately will blow up if it is not
of length 6. Next, it sets the eax register to 0. After this, it does a loop in which it shifts to the
correct letter, starting at the first letter, and checks its first 4 digits in binary. It will add this to
the pointer for a big string that the program references from memory and look at the first byte with
zero extension. Then it will store this value in rsp + the character number it is. It then adds 1 to rax to
signify that it is onto the next letter and will continue for all 6 characters. Later, it will use these
generated numbers and compare them to the word in memory that the string should equal, "memory," and if this
is true, it will defuse the bomb. In order to understand which characters to input initially, one must consider
Unicode characters and their hexidecimal equivalents. In this function, you can traverse the large string in
memory by choosing a letter that's last 4 digits are how much you would shift the string's letters by to get
the corresponding letter in "memory."
